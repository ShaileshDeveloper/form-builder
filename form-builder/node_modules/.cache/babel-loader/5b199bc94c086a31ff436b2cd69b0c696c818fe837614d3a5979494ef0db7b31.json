{"ast":null,"code":"/**\r\n * browser/dataFile.js\r\n *\r\n * Copyright (c) 2012-2019 mooster@42at.com\r\n * https://github.com/moos/wordpos\r\n *\r\n * Portions: Copyright (c) 2011, Chris Umbel\r\n *\r\n * Released under MIT license\r\n */\n\nconst {\n  lineDataToJSON,\n  LEX_NAMES\n} = require('../common');\nconst {\n  zeroPad\n} = require('../util');\nconst BaseFile = require('./baseFile');\n\n/**\r\n * get parsed line from data file\r\n *\r\n * @param  {string} offset The offset key\r\n * @return {object} Data record object\r\n * @this DataFile\r\n */\nfunction seek(offset) {\n  let str = this.file[offset];\n  if (!str) return {};\n  // offset was extracted for the key - add it back to line data\n  return lineDataToJSON(offset + ' ' + str);\n}\n\n/**\r\n * lookup offsets in data file\r\n *\r\n * @param offsets {array} - array of offsets to lookup (obtained from index.find())\r\n * @param callback{function} (optional) - callback function\r\n * @returns {Promise.[<Object>]} array of or single data record\r\n * @this DataFile\r\n */\nfunction lookup(offsets, callback) {\n  var results = [],\n    self = this,\n    readLine = seek.bind(this),\n    valid = item => item.pos,\n    single = !Array.isArray(offsets);\n  if (single) offsets = [offsets];\n  return new Promise(function (resolve, reject) {\n    results = offsets.map(zeroPad).map(readLine).filter(valid);\n    if (!results.length) {\n      let err = new RangeError(`No data at offsets ${offsets.join()} in ${self.filePath}.`);\n      callback && callback(err, single ? {} : []);\n      reject(err);\n    } else {\n      if (single) results = results[0];\n      callback && callback(null, results);\n      resolve(results);\n    }\n  });\n}\n\n/**\r\n * DataFile class\r\n *\r\n * @param dictPath {string} - path to dict folder\r\n * @param posName {string} - POS name\r\n * @constructor\r\n */\nclass DataFile extends BaseFile {\n  constructor(dictPath, posName) {\n    super('data', dictPath, posName);\n  }\n  lookup() {\n    return this.ready(lookup, arguments);\n  }\n}\n\n/**\r\n * map of lexFilenum to lex names\r\n *\r\n * @see https://wordnet.princeton.edu/wordnet/man/lexnames.5WN.html\r\n * @type {string[]}\r\n */\nDataFile.LEX_NAMES = LEX_NAMES;\nmodule.exports = DataFile;","map":{"version":3,"names":["lineDataToJSON","LEX_NAMES","require","zeroPad","BaseFile","seek","offset","str","file","lookup","offsets","callback","results","self","readLine","bind","valid","item","pos","single","Array","isArray","Promise","resolve","reject","map","filter","length","err","RangeError","join","filePath","DataFile","constructor","dictPath","posName","ready","arguments","module","exports"],"sources":["C:/Users/shail/OneDrive/Documents/GitHub/form-builder/form-builder/node_modules/wordpos/src/browser/dataFile.js"],"sourcesContent":["/**\r\n * browser/dataFile.js\r\n *\r\n * Copyright (c) 2012-2019 mooster@42at.com\r\n * https://github.com/moos/wordpos\r\n *\r\n * Portions: Copyright (c) 2011, Chris Umbel\r\n *\r\n * Released under MIT license\r\n */\r\n\r\nconst { lineDataToJSON, LEX_NAMES } = require('../common');\r\nconst { zeroPad } = require('../util');\r\nconst BaseFile = require('./baseFile');\r\n\r\n/**\r\n * get parsed line from data file\r\n *\r\n * @param  {string} offset The offset key\r\n * @return {object} Data record object\r\n * @this DataFile\r\n */\r\nfunction seek(offset) {\r\n  let str = this.file[offset];\r\n  if (!str) return {};\r\n  // offset was extracted for the key - add it back to line data\r\n  return lineDataToJSON(offset + ' ' + str);\r\n}\r\n\r\n/**\r\n * lookup offsets in data file\r\n *\r\n * @param offsets {array} - array of offsets to lookup (obtained from index.find())\r\n * @param callback{function} (optional) - callback function\r\n * @returns {Promise.[<Object>]} array of or single data record\r\n * @this DataFile\r\n */\r\nfunction lookup(offsets, callback) {\r\n  var results = [],\r\n    self = this,\r\n    readLine = seek.bind(this),\r\n    valid = (item => item.pos),\r\n    single = !Array.isArray(offsets);\r\n\r\n  if (single) offsets = [offsets];\r\n  return new Promise(function(resolve, reject) {\r\n    results = offsets\r\n      .map(zeroPad)\r\n      .map(readLine)\r\n      .filter(valid);\r\n\r\n    if (!results.length) {\r\n      let err = new RangeError(`No data at offsets ${offsets.join()} in ${self.filePath}.`);\r\n      callback && callback(err, single ? {} :[]);\r\n      reject(err);\r\n    } else {\r\n      if (single) results = results[0];\r\n      callback && callback(null, results);\r\n      resolve(results);\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * DataFile class\r\n *\r\n * @param dictPath {string} - path to dict folder\r\n * @param posName {string} - POS name\r\n * @constructor\r\n */\r\nclass DataFile extends BaseFile {\r\n\r\n  constructor(dictPath, posName) {\r\n    super('data', dictPath, posName);\r\n  }\r\n\r\n  lookup() {\r\n    return this.ready(lookup, arguments);\r\n  }\r\n}\r\n\r\n/**\r\n * map of lexFilenum to lex names\r\n *\r\n * @see https://wordnet.princeton.edu/wordnet/man/lexnames.5WN.html\r\n * @type {string[]}\r\n */\r\nDataFile.LEX_NAMES = LEX_NAMES;\r\n\r\nmodule.exports = DataFile;\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAM;EAAEA,cAAc;EAAEC;AAAU,CAAC,GAAGC,OAAO,CAAC,WAAW,CAAC;AAC1D,MAAM;EAAEC;AAAQ,CAAC,GAAGD,OAAO,CAAC,SAAS,CAAC;AACtC,MAAME,QAAQ,GAAGF,OAAO,CAAC,YAAY,CAAC;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASG,IAAI,CAACC,MAAM,EAAE;EACpB,IAAIC,GAAG,GAAG,IAAI,CAACC,IAAI,CAACF,MAAM,CAAC;EAC3B,IAAI,CAACC,GAAG,EAAE,OAAO,CAAC,CAAC;EACnB;EACA,OAAOP,cAAc,CAACM,MAAM,GAAG,GAAG,GAAGC,GAAG,CAAC;AAC3C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASE,MAAM,CAACC,OAAO,EAAEC,QAAQ,EAAE;EACjC,IAAIC,OAAO,GAAG,EAAE;IACdC,IAAI,GAAG,IAAI;IACXC,QAAQ,GAAGT,IAAI,CAACU,IAAI,CAAC,IAAI,CAAC;IAC1BC,KAAK,GAAIC,IAAI,IAAIA,IAAI,CAACC,GAAI;IAC1BC,MAAM,GAAG,CAACC,KAAK,CAACC,OAAO,CAACX,OAAO,CAAC;EAElC,IAAIS,MAAM,EAAET,OAAO,GAAG,CAACA,OAAO,CAAC;EAC/B,OAAO,IAAIY,OAAO,CAAC,UAASC,OAAO,EAAEC,MAAM,EAAE;IAC3CZ,OAAO,GAAGF,OAAO,CACde,GAAG,CAACtB,OAAO,CAAC,CACZsB,GAAG,CAACX,QAAQ,CAAC,CACbY,MAAM,CAACV,KAAK,CAAC;IAEhB,IAAI,CAACJ,OAAO,CAACe,MAAM,EAAE;MACnB,IAAIC,GAAG,GAAG,IAAIC,UAAU,CAAE,sBAAqBnB,OAAO,CAACoB,IAAI,EAAG,OAAMjB,IAAI,CAACkB,QAAS,GAAE,CAAC;MACrFpB,QAAQ,IAAIA,QAAQ,CAACiB,GAAG,EAAET,MAAM,GAAG,CAAC,CAAC,GAAE,EAAE,CAAC;MAC1CK,MAAM,CAACI,GAAG,CAAC;IACb,CAAC,MAAM;MACL,IAAIT,MAAM,EAAEP,OAAO,GAAGA,OAAO,CAAC,CAAC,CAAC;MAChCD,QAAQ,IAAIA,QAAQ,CAAC,IAAI,EAAEC,OAAO,CAAC;MACnCW,OAAO,CAACX,OAAO,CAAC;IAClB;EACF,CAAC,CAAC;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMoB,QAAQ,SAAS5B,QAAQ,CAAC;EAE9B6B,WAAW,CAACC,QAAQ,EAAEC,OAAO,EAAE;IAC7B,KAAK,CAAC,MAAM,EAAED,QAAQ,EAAEC,OAAO,CAAC;EAClC;EAEA1B,MAAM,GAAG;IACP,OAAO,IAAI,CAAC2B,KAAK,CAAC3B,MAAM,EAAE4B,SAAS,CAAC;EACtC;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACAL,QAAQ,CAAC/B,SAAS,GAAGA,SAAS;AAE9BqC,MAAM,CAACC,OAAO,GAAGP,QAAQ"},"metadata":{},"sourceType":"script","externalDependencies":[]}
{"ast":null,"code":"/**\r\n* common.js\r\n*\r\n* Copyright (c) 2012-2019 mooster@42at.com\r\n* https://github.com/moos/wordpos\r\n*\r\n* Portions: Copyright (c) 2011, Chris Umbel\r\n*\r\n* Released under MIT license\r\n*/\n\nvar {\n  normalize,\n  nextTick,\n  isString,\n  uniq,\n  sample,\n  diff,\n  flat\n} = require('./util');\nfunction error(err, callback) {\n  if (isString(err)) err = new RangeError(err);\n  callback && callback(err, {});\n  return Promise.reject(err);\n}\n\n/**\r\n * factory for main lookup function\r\n *\r\n * @param pos {string} - n/v/a/r\r\n * @returns {Function} - lookup function bound to POS\r\n * @this WordPOS\r\n */\nfunction lookup(pos) {\n  return function (word, callback) {\n    var profile = this.options.profile,\n      start = profile && new Date(),\n      files = this.getFilesFor(pos),\n      args = [];\n    word = normalize(word);\n\n    // lookup index\n    return files.index.lookup(word).then(function (result) {\n      if (result) {\n        // lookup data\n        return files.data.lookup(result.synsetOffset).then(done);\n      } else {\n        // not found in index\n        return done([]);\n      }\n    }).catch(done);\n    function done(results) {\n      if (results instanceof Error) {\n        args.push([], word);\n      } else {\n        args.push(results, word);\n      }\n      //console.log(3333, args)\n      profile && args.push(new Date() - start);\n      nextTick(callback, args);\n      return results;\n    }\n  };\n}\n\n/**\r\n * find a word and prepare its lexical record\r\n *\r\n * @param word {string} - search word\r\n * @param callback {function} - callback function receives result\r\n * @returns {Promise.<IndexRecord>}\r\n * @this IndexFile\r\n *\r\n * Credit for this routine to https://github.com/NaturalNode/natural\r\n */\nfunction indexLookup(word, callback) {\n  var self = this;\n  return new Promise(function (resolve, reject) {\n    self.find(word, function (record) {\n      var indexRecord = null,\n        i;\n      if (record.status == 'hit') {\n        var ptrs = [],\n          offsets = [];\n        let n = parseInt(record.tokens[3]);\n        for (i = 0; i < n; i++) {\n          ptrs.push(record.tokens[i]);\n        }\n        n = parseInt(record.tokens[2]);\n        for (i = 0; i < n; i++) {\n          offsets.push(record.tokens[ptrs.length + 6 + i]);\n        }\n        indexRecord = {\n          lemma: record.tokens[0],\n          pos: record.tokens[1],\n          ptrSymbol: ptrs,\n          senseCnt: parseInt(record.tokens[ptrs.length + 4], 10),\n          tagsenseCnt: parseInt(record.tokens[ptrs.length + 5], 10),\n          synsetOffset: offsets\n        };\n      }\n      callback && callback(indexRecord);\n      resolve(indexRecord);\n    });\n  });\n}\n\n/**\r\n * lookup a word in all indexes\r\n *\r\n * @param word {string} - search word\r\n * @param callback {Function} (optional) - callback with (results, word) signature\r\n * @returns {Promise}\r\n * @this WordPOS\r\n */\nfunction lookupPOS(word, callback) {\n  var self = this,\n    results = [],\n    profile = this.options.profile,\n    start = profile && new Date(),\n    methods = ['lookupAdverb', 'lookupAdjective', 'lookupVerb', 'lookupNoun'];\n  return Promise.all(methods.map(exec)).then(done).catch(error);\n  function exec(method) {\n    return self[method].call(self, word).then(function collect(result) {\n      results = results.concat(result);\n    });\n  }\n  function done() {\n    var args = [results, word];\n    profile && args.push(new Date() - start);\n    nextTick(callback, args);\n    return results;\n  }\n  function error(err) {\n    nextTick(callback, [[], word]);\n    throw err;\n  }\n}\n\n/**\r\n * getX() factory function\r\n *\r\n * @param isFn {function} - an isX() function\r\n * @returns {Function}\r\n * @this IndexFile\r\n */\nfunction get(isFn) {\n  return function (text, callback, _noprofile) {\n    var profile = this.options.profile && !_noprofile,\n      start = profile && new Date(),\n      words = this.parse(text),\n      results = [],\n      self = this,\n      first = words[0];\n\n    // test one first & check for error, otherwise\n    // map is inoccuous to errors!\n    return exec(first).then(() => Promise.all(words.slice(1).map(exec))).then(done).catch(err => {\n      // done(); // callback signature is same!  // FIXME\n      return Promise.reject(err);\n    });\n    function exec(word) {\n      return self[isFn].call(self, word, null, /*_noprofile*/true).then(function collect(result) {\n        result && results.push(word);\n      });\n    }\n    function done() {\n      var args = [results];\n      profile && args.push(new Date() - start);\n      nextTick(callback, args);\n      return results;\n    }\n  };\n}\n\n/**\r\n * getPOS() - Find all POS for all words in given string\r\n *\r\n * @param text {string} - words to lookup for POS\r\n * @param callback {function} (optional) - receives object with words broken into POS or 'rest', ie,\r\n * \t    Object: {nouns:[], verbs:[], adjectives:[], adverbs:[], rest:[]}\r\n * @return Promise - resolve function receives data object\r\n */\nfunction getPOS(text, callback) {\n  var self = this,\n    data = {\n      nouns: [],\n      verbs: [],\n      adjectives: [],\n      adverbs: [],\n      rest: []\n    },\n    profile = this.options.profile,\n    start = profile && new Date(),\n    words = this.parse(text),\n    methods = ['getAdverbs', 'getAdjectives', 'getVerbs', 'getNouns'];\n  return Promise.all(methods.map(exec)).then(done).catch(error);\n  function exec(method) {\n    return self[method].call(self, text, null, true).then(function collect(results) {\n      // getAdjectives --> adjectives\n      var pos = method.replace('get', '').toLowerCase();\n      data[pos] = results;\n    });\n  }\n  function done() {\n    var args = [data];\n    var matches = uniq(flat(Object.values(data)));\n    data.rest = diff(words, matches);\n    profile && args.push(new Date() - start);\n    nextTick(callback, args);\n    return data;\n  }\n  function error(err) {\n    console.log('Error >>> ', err);\n    nextTick(callback, []);\n    throw err;\n  }\n}\n\n/**\r\n * isX() factory function\r\n *\r\n * @param pos {string} - n/v/a/r\r\n * @returns {Function}\r\n * @this WordPOS\r\n */\nfunction is(pos) {\n  return function (word, callback, _noprofile) {\n    // disable profiling when isX() used internally\n    var profile = this.options.profile && !_noprofile,\n      start = profile && new Date(),\n      args = [],\n      index = this.getFilesFor(pos).index;\n    word = normalize(word);\n    return index.lookup(word).then(function (record) {\n      var result = !!record;\n      args.push(result, word);\n      profile && args.push(new Date() - start);\n      nextTick(callback, args);\n      return result;\n    });\n  };\n}\n\n/**\r\n * parse a single data file line, returning data object\r\n *\r\n * @param line {string} - a single line from WordNet data file\r\n * @returns {object}\r\n *\r\n * Credit for this routine to https://github.com/NaturalNode/natural\r\n */\nfunction lineDataToJSON(line, location) {\n  var data = line.split('| '),\n    tokens = data[0].split(/\\s+/),\n    ptrs = [],\n    wCnt = parseInt(tokens[3], 16),\n    synonyms = [],\n    i;\n  for (i = 0; i < wCnt; i++) {\n    synonyms.push(tokens[4 + i * 2]);\n  }\n  var ptrOffset = (wCnt - 1) * 2 + 6;\n  let n = parseInt(tokens[ptrOffset], 10);\n  for (i = 0; i < n; i++) {\n    ptrs.push({\n      pointerSymbol: tokens[ptrOffset + 1 + i * 4],\n      synsetOffset: tokens[ptrOffset + 2 + i * 4],\n      pos: tokens[ptrOffset + 3 + i * 4],\n      sourceTarget: tokens[ptrOffset + 4 + i * 4]\n    });\n  }\n\n  // break \"gloss\" into definition vs. examples\n  var glossArray = data[1].split('; ');\n  var definition = glossArray[0];\n  var examples = glossArray.slice(1);\n  var lexFilenum = parseInt(tokens[1], 10);\n  for (var k = 0; k < examples.length; k++) {\n    examples[k] = examples[k].replace(/\\\"/g, '').replace(/\\s\\s+/g, '');\n  }\n  return {\n    synsetOffset: tokens[0],\n    lexFilenum: lexFilenum,\n    lexName: LEX_NAMES[lexFilenum],\n    pos: tokens[2],\n    wCnt: wCnt,\n    lemma: tokens[4],\n    synonyms: synonyms,\n    lexId: tokens[5],\n    ptrs: ptrs,\n    gloss: data[1],\n    def: definition,\n    exp: examples\n  };\n}\n\n/**\r\n * seek - get record at offset for pos\r\n *\r\n * @param offset {number} - synset offset\r\n * @param pos {string} - POS a/r/n/v\r\n * @param callback {function} - optional callback\r\n * @returns Promise\r\n * @this WordPOS\r\n */\nfunction seek(offset, pos, callback) {\n  var offsetTmp = Number(offset);\n  if (isNaN(offsetTmp) || offsetTmp <= 0) return error('Offset must be valid positive number: ' + offset, callback);\n  var data = this.getFilesFor(pos).data;\n  if (!data) return error('Incorrect POS - 2nd argument must be a, r, n or v.', callback);\n  return data.lookup(offset, callback);\n}\nconst LEX_NAMES = ['adj.all', 'adj.pert', 'adv.all', 'noun.Tops', 'noun.act', 'noun.animal', 'noun.artifact', 'noun.attribute', 'noun.body', 'noun.cognition', 'noun.communication', 'noun.event', 'noun.feeling', 'noun.food', 'noun.group', 'noun.location', 'noun.motive', 'noun.object', 'noun.person', 'noun.phenomenon', 'noun.plant', 'noun.possession', 'noun.process', 'noun.quantity', 'noun.relation', 'noun.shape', 'noun.state', 'noun.substance', 'noun.time', 'verb.body', 'verb.change', 'verb.cognition', 'verb.communication', 'verb.competition', 'verb.consumption', 'verb.contact', 'verb.creation', 'verb.emotion', 'verb.motion', 'verb.perception', 'verb.possession', 'verb.social', 'verb.stative', 'verb.weather', 'adj.ppl'];\nmodule.exports = {\n  indexLookup,\n  is,\n  get,\n  seek,\n  getPOS,\n  lineDataToJSON,\n  LEX_NAMES,\n  lookup,\n  lookupPOS\n};","map":{"version":3,"names":["normalize","nextTick","isString","uniq","sample","diff","flat","require","error","err","callback","RangeError","Promise","reject","lookup","pos","word","profile","options","start","Date","files","getFilesFor","args","index","then","result","data","synsetOffset","done","catch","results","Error","push","indexLookup","self","resolve","find","record","indexRecord","i","status","ptrs","offsets","n","parseInt","tokens","length","lemma","ptrSymbol","senseCnt","tagsenseCnt","lookupPOS","methods","all","map","exec","method","call","collect","concat","get","isFn","text","_noprofile","words","parse","first","slice","getPOS","nouns","verbs","adjectives","adverbs","rest","replace","toLowerCase","matches","Object","values","console","log","is","lineDataToJSON","line","location","split","wCnt","synonyms","ptrOffset","pointerSymbol","sourceTarget","glossArray","definition","examples","lexFilenum","k","lexName","LEX_NAMES","lexId","gloss","def","exp","seek","offset","offsetTmp","Number","isNaN","module","exports"],"sources":["C:/Users/shail/OneDrive/Documents/GitHub/form-builder/form-builder/node_modules/wordpos/src/common.js"],"sourcesContent":["/**\r\n* common.js\r\n*\r\n* Copyright (c) 2012-2019 mooster@42at.com\r\n* https://github.com/moos/wordpos\r\n*\r\n* Portions: Copyright (c) 2011, Chris Umbel\r\n*\r\n* Released under MIT license\r\n*/\r\n\r\nvar { normalize, nextTick, isString, uniq, sample, diff, flat } = require('./util');\r\n\r\nfunction error(err, callback) {\r\n  if (isString(err)) err = new RangeError(err);\r\n  callback && callback(err, {});\r\n  return Promise.reject(err);\r\n}\r\n\r\n/**\r\n * factory for main lookup function\r\n *\r\n * @param pos {string} - n/v/a/r\r\n * @returns {Function} - lookup function bound to POS\r\n * @this WordPOS\r\n */\r\nfunction lookup(pos) {\r\n  return function(word, callback) {\r\n    var profile = this.options.profile,\r\n      start = profile && new Date(),\r\n      files = this.getFilesFor(pos),\r\n      args = [];\r\n\r\n    word = normalize(word);\r\n\r\n    // lookup index\r\n    return files.index.lookup(word)\r\n      .then(function(result) {\r\n        if (result) {\r\n          // lookup data\r\n          return files.data.lookup(result.synsetOffset).then(done);\r\n        } else {\r\n          // not found in index\r\n          return done([]);\r\n        }\r\n      })\r\n      .catch(done);\r\n\r\n    function done(results) {\r\n      if (results instanceof Error) {\r\n        args.push([], word);\r\n      } else {\r\n        args.push(results, word);\r\n      }\r\n      //console.log(3333, args)\r\n      profile && args.push(new Date() - start);\r\n      nextTick(callback, args);\r\n      return results;\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * find a word and prepare its lexical record\r\n *\r\n * @param word {string} - search word\r\n * @param callback {function} - callback function receives result\r\n * @returns {Promise.<IndexRecord>}\r\n * @this IndexFile\r\n *\r\n * Credit for this routine to https://github.com/NaturalNode/natural\r\n */\r\nfunction indexLookup(word, callback) {\r\n  var self = this;\r\n  return new Promise(function(resolve, reject){\r\n    self.find(word, function (record) {\r\n      var indexRecord = null,\r\n        i;\r\n\r\n      if (record.status == 'hit') {\r\n        var ptrs = [], offsets = [];\r\n        let n = parseInt(record.tokens[3]);\r\n\r\n        for (i = 0; i < n; i++) {\r\n          ptrs.push(record.tokens[i]);\r\n        }\r\n\r\n        n = parseInt(record.tokens[2]);\r\n        for (i = 0; i < n; i++) {\r\n          offsets.push(record.tokens[ptrs.length + 6 + i]);\r\n        }\r\n\r\n        indexRecord = {\r\n          lemma       : record.tokens[0],\r\n          pos         : record.tokens[1],\r\n          ptrSymbol   : ptrs,\r\n          senseCnt    : parseInt(record.tokens[ptrs.length + 4], 10),\r\n          tagsenseCnt : parseInt(record.tokens[ptrs.length + 5], 10),\r\n          synsetOffset: offsets\r\n        };\r\n      }\r\n      callback && callback(indexRecord);\r\n      resolve(indexRecord);\r\n    });\r\n  });\r\n}\r\n\r\n/**\r\n * lookup a word in all indexes\r\n *\r\n * @param word {string} - search word\r\n * @param callback {Function} (optional) - callback with (results, word) signature\r\n * @returns {Promise}\r\n * @this WordPOS\r\n */\r\nfunction lookupPOS(word, callback) {\r\n  var self = this,\r\n    results = [],\r\n    profile = this.options.profile,\r\n    start = profile && new Date(),\r\n    methods = ['lookupAdverb', 'lookupAdjective', 'lookupVerb', 'lookupNoun'];\r\n\r\n  return Promise\r\n    .all(methods.map(exec))\r\n    .then(done)\r\n    .catch(error);\r\n\r\n  function exec(method) {\r\n    return self[ method ]\r\n      .call(self, word)\r\n      .then(function collect(result){\r\n        results = results.concat(result);\r\n      });\r\n  }\r\n\r\n  function done() {\r\n    var args = [results, word];\r\n    profile && args.push(new Date() - start);\r\n    nextTick(callback, args);\r\n    return results;\r\n  }\r\n\r\n  function error(err) {\r\n    nextTick(callback, [[], word]);\r\n    throw err;\r\n  }\r\n}\r\n\r\n/**\r\n * getX() factory function\r\n *\r\n * @param isFn {function} - an isX() function\r\n * @returns {Function}\r\n * @this IndexFile\r\n */\r\nfunction get(isFn) {\r\n  return function(text, callback, _noprofile) {\r\n    var profile = this.options.profile && !_noprofile,\r\n      start = profile && new Date(),\r\n      words = this.parse(text),\r\n      results = [],\r\n      self = this,\r\n      first = words[0];\r\n\r\n    // test one first & check for error, otherwise\r\n    // map is inoccuous to errors!\r\n    return exec(first)\r\n      .then(() => Promise.all(words.slice(1).map(exec)))\r\n      .then(done)\r\n      .catch(err => {\r\n        // done(); // callback signature is same!  // FIXME\r\n        return Promise.reject(err);\r\n      });\r\n\r\n    function exec(word) {\r\n      return self[isFn]\r\n        .call(self, word, null, /*_noprofile*/ true)\r\n        .then(function collect(result) {\r\n          result && results.push(word);\r\n        });\r\n    }\r\n\r\n    function done(){\r\n      var args = [results];\r\n      profile && args.push(new Date() - start);\r\n      nextTick(callback, args);\r\n      return results;\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * getPOS() - Find all POS for all words in given string\r\n *\r\n * @param text {string} - words to lookup for POS\r\n * @param callback {function} (optional) - receives object with words broken into POS or 'rest', ie,\r\n * \t    Object: {nouns:[], verbs:[], adjectives:[], adverbs:[], rest:[]}\r\n * @return Promise - resolve function receives data object\r\n */\r\nfunction getPOS(text, callback) {\r\n  var self = this,\r\n    data = {nouns:[], verbs:[], adjectives:[], adverbs:[], rest:[]},\r\n    profile = this.options.profile,\r\n    start = profile && new Date(),\r\n    words = this.parse(text),\r\n    methods = ['getAdverbs', 'getAdjectives', 'getVerbs', 'getNouns'];\r\n\r\n  return Promise\r\n    .all(methods.map(exec))\r\n    .then(done)\r\n    .catch(error);\r\n\r\n  function exec(method) {\r\n    return self[ method ]\r\n      .call(self, text, null, true)\r\n      .then(function collect(results) {\r\n        // getAdjectives --> adjectives\r\n        var pos = method.replace('get','').toLowerCase();\r\n        data[ pos ] =  results;\r\n      });\r\n  }\r\n\r\n  function done() {\r\n    var args = [data];\r\n    var matches = uniq(flat(Object.values(data)));\r\n    data.rest = diff(words, matches);\r\n    profile && args.push(new Date() - start);\r\n    nextTick(callback, args);\r\n    return data;\r\n  }\r\n\r\n  function error(err) {\r\n    console.log('Error >>> ', err);\r\n    nextTick(callback, []);\r\n    throw err;\r\n  }\r\n}\r\n\r\n/**\r\n * isX() factory function\r\n *\r\n * @param pos {string} - n/v/a/r\r\n * @returns {Function}\r\n * @this WordPOS\r\n */\r\nfunction is(pos){\r\n  return function(word, callback, _noprofile) {\r\n    // disable profiling when isX() used internally\r\n    var profile = this.options.profile && !_noprofile,\r\n      start = profile && new Date(),\r\n      args = [],\r\n      index = this.getFilesFor(pos).index;\r\n    word = normalize(word);\r\n\r\n    return index\r\n      .lookup(word)\r\n      .then(function(record) {\r\n        var result = !!record;\r\n        args.push(result, word);\r\n        profile && args.push(new Date() - start);\r\n        nextTick(callback, args);\r\n        return result;\r\n      });\r\n  };\r\n}\r\n\r\n/**\r\n * parse a single data file line, returning data object\r\n *\r\n * @param line {string} - a single line from WordNet data file\r\n * @returns {object}\r\n *\r\n * Credit for this routine to https://github.com/NaturalNode/natural\r\n */\r\nfunction lineDataToJSON(line, location) {\r\n  var data = line.split('| '),\r\n    tokens = data[0].split(/\\s+/),\r\n    ptrs = [],\r\n    wCnt = parseInt(tokens[3], 16),\r\n    synonyms = [],\r\n    i;\r\n\r\n  for(i = 0; i < wCnt; i++) {\r\n    synonyms.push(tokens[4 + i * 2]);\r\n  }\r\n\r\n  var ptrOffset = (wCnt - 1) * 2 + 6;\r\n  let n = parseInt(tokens[ptrOffset], 10);\r\n  for(i = 0; i < n; i++) {\r\n    ptrs.push({\r\n      pointerSymbol: tokens[ptrOffset + 1 + i * 4],\r\n      synsetOffset: tokens[ptrOffset + 2 + i * 4],\r\n      pos: tokens[ptrOffset + 3 + i * 4],\r\n      sourceTarget: tokens[ptrOffset + 4 + i * 4]\r\n    });\r\n  }\r\n\r\n  // break \"gloss\" into definition vs. examples\r\n  var glossArray = data[1].split('; ');\r\n  var definition = glossArray[0];\r\n  var examples = glossArray.slice(1);\r\n  var lexFilenum = parseInt(tokens[1], 10);\r\n\r\n  for (var k = 0; k < examples.length; k++) {\r\n    examples[k] = examples[k].replace(/\\\"/g,'').replace(/\\s\\s+/g,'');\r\n  }\r\n\r\n  return {\r\n    synsetOffset: tokens[0],\r\n    lexFilenum: lexFilenum,\r\n    lexName: LEX_NAMES[ lexFilenum ],\r\n    pos: tokens[2],\r\n    wCnt: wCnt,\r\n    lemma: tokens[4],\r\n    synonyms: synonyms,\r\n    lexId: tokens[5],\r\n    ptrs: ptrs,\r\n    gloss: data[1],\r\n    def: definition,\r\n    exp: examples\r\n  };\r\n}\r\n\r\n\r\n/**\r\n * seek - get record at offset for pos\r\n *\r\n * @param offset {number} - synset offset\r\n * @param pos {string} - POS a/r/n/v\r\n * @param callback {function} - optional callback\r\n * @returns Promise\r\n * @this WordPOS\r\n */\r\nfunction seek(offset, pos, callback){\r\n  var offsetTmp = Number(offset);\r\n  if (isNaN(offsetTmp) || offsetTmp <= 0) return error('Offset must be valid positive number: ' + offset, callback);\r\n\r\n  var data = this.getFilesFor(pos).data;\r\n  if (!data) return error('Incorrect POS - 2nd argument must be a, r, n or v.', callback);\r\n\r\n  return data.lookup(offset, callback);\r\n}\r\n\r\nconst LEX_NAMES = [\r\n 'adj.all',\r\n 'adj.pert',\r\n 'adv.all',\r\n 'noun.Tops',\r\n 'noun.act',\r\n 'noun.animal',\r\n 'noun.artifact',\r\n 'noun.attribute',\r\n 'noun.body',\r\n 'noun.cognition',\r\n 'noun.communication',\r\n 'noun.event',\r\n 'noun.feeling',\r\n 'noun.food',\r\n 'noun.group',\r\n 'noun.location',\r\n 'noun.motive',\r\n 'noun.object',\r\n 'noun.person',\r\n 'noun.phenomenon',\r\n 'noun.plant',\r\n 'noun.possession',\r\n 'noun.process',\r\n 'noun.quantity',\r\n 'noun.relation',\r\n 'noun.shape',\r\n 'noun.state',\r\n 'noun.substance',\r\n 'noun.time',\r\n 'verb.body',\r\n 'verb.change',\r\n 'verb.cognition',\r\n 'verb.communication',\r\n 'verb.competition',\r\n 'verb.consumption',\r\n 'verb.contact',\r\n 'verb.creation',\r\n 'verb.emotion',\r\n 'verb.motion',\r\n 'verb.perception',\r\n 'verb.possession',\r\n 'verb.social',\r\n 'verb.stative',\r\n 'verb.weather',\r\n 'adj.ppl'\r\n];\r\n\r\nmodule.exports= {\r\n  indexLookup,\r\n  is,\r\n  get,\r\n  seek,\r\n  getPOS,\r\n\r\n  lineDataToJSON,\r\n  LEX_NAMES,\r\n  lookup,\r\n  lookupPOS\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}